import Foundation

// MARK: - Argus Config (Churn & Safety)
struct ArgusConfig: Codable, Sendable {
    static let defaults = ArgusConfig()
    
    // 1. Manual Override
    var manualOverrideDuration: TimeInterval = 86400 // 24 Hours
    
    // 2. Cooldowns
    var cooldownPulse: TimeInterval = 300 // 5 Mins
    var cooldownCorse: TimeInterval = 2700 // 45 Mins
    var minHoldCorse: TimeInterval = 7200 // 2 Hours
    
    // 3. Hysteresis (Thresholds)
    var entryThreshold: Double = 60.0
    var exitThreshold: Double = 45.0
    var reEntryThreshold: Double = 75.0
    var reEntryWindow: TimeInterval = 900 // 15 Mins
    
    // 4. Idempotency
    var enableIdempotency: Bool = true
    
    // 5. Decision Thresholds (Extracted from ArgusDecisionEngine)
    var defaultTechAuthority: Double = 0.85
    var defaultAggressiveness: Double = 0.55
    var defaultBuyThreshold: Double = 55.0
    var defaultSellThreshold: Double = 45.0
    var aggressivenessMultiplier: Double = 20.0
    
    // 6. Data Health Gates
    var totalModules: Double = 4.0
    var minCoveragePct: Double = 60.0
    
    // 7. Consensus Calculation
    var supportImpactMultiplier: Double = 10.0
    var objectionImpactMultiplier: Double = 25.0
    
    // 8. Tier System
    var tier1Threshold: Double = 85.0
    var tier2Threshold: Double = 70.0
    var tier3Threshold: Double = 60.0
    
    // 9. Quality Gates
    var qualityGateTier1: Double = 0.8
    var qualityGateTier2: Double = 0.5
    var qualityGateMinimum: Double = 0.4
    
    // 10. Technical Veto
    var strongTechObjectionThreshold: Double = 60.0
    var weakTechObjectionThreshold: Double = 40.0
    
    // 11. Position Sizing
    var sizeReductionThreshold: Double = 0.5
    
    // 12. ATR-based Risk Management
    var atrStopMultiplier: Double = 2.0
    var atrTargetMultiplier: Double = 3.0
    var defaultRiskTolerance: Double = 0.05
    var maxDrawdown: Double = 3.0
    
    // 13. Execution
    var validityWindow: TimeInterval = 300 // 5 Minutes
}

// MARK: - Churn Enums
enum ChurnReason: String, Codable {
    case manualOverride = "Manual Override (24h Rule)"
    case cooldownPulse = "Cooldown (Pulse 5m)"
    case cooldownCorse = "Cooldown (Corse 45m)"
    case minHold = "Min Hold (Corse 2h)"
    case hysteresis = "Hysteresis (Re-Entry)"
    case idempotency = "Idempotency (Duplicate)"
    case riskExposure = "Risk Exposure Limit"
}

/// The final computed output of the system, acting as the "Brain".
struct ArgusDecisionResult: Codable {
    let id: UUID
    let symbol: String
    
    // Asset Context
    let assetType: SafeAssetType // Added for UI Context
    
    // Component Scores
    let atlasScore: Double      // Fundamental (0-100)
    let aetherScore: Double     // Macro Regime (0-100)
    let orionScore: Double      // Technical (0-100)
    let athenaScore: Double     // Athena (Factors) (0-100)
    let hermesScore: Double     // News (0-100)
    let demeterScore: Double    // Sector Analysis (0-100)
    
    // Detailed Results
    // Detailed Results
    let orionDetails: OrionScoreResult?
    let chironResult: ChironResult? // NEW: Chiron Engine Output
    let phoenixAdvice: PhoenixAdvice? // NEW: Phoenix Level Engine Output
    let bistDetails: BistDecisionResult? // NEW: BIST V2 Output
    let standardizedOutputs: [String: StandardModuleOutput]? // Export V2
    let moduleWeights: [String: Double]? // NEW: Information Quality Weights for UI
    
    // Final Output (Dual Mode)
    let finalScoreCore: Double
    let finalScorePulse: Double
    
    let letterGradeCore: String
    let letterGradePulse: String
    
    let finalActionCore: SignalAction
    let finalActionPulse: SignalAction
    
    // Explanation Flags
    let isNewsBacked: Bool      // Hermes strong?
    let isRegimeGood: Bool      // Aether > 50?
    let isFundamentallyStrong: Bool // Atlas > 50?
    let isDemeterStrong: Bool   // Demeter > 50?
    
    let generatedAt: Date
}

// Support for Pulse/Core Mode
// Support for Pulse/Core Mode
enum ArgusTimeframeMode: String, CaseIterable, Codable {
    case core = "Core"
    case pulse = "Pulse"
}




// MARK: - Argus AI Explanation
/// The text interpretation generated by Gemini, explaining the numbers.
struct ArgusExplanation: Codable {
    let title: String           // e.g. "Dengeli ama fırsat barındıran B+"
    let summary: String         // 2-3 sentences overview
    let bullets: [String]       // 3-5 bullet points
    let riskNote: String?       // Optional warning
    let toneTag: String?        // "conservative", "aggressive"
    
    // Meta (not from AI)
    var createdAt: Date = Date()
    var isOffline: Bool = false
    
    enum CodingKeys: String, CodingKey {
        case title, summary, bullets, riskNote, toneTag, createdAt, isOffline
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.title = try container.decode(String.self, forKey: .title)
        self.summary = try container.decode(String.self, forKey: .summary)
        self.bullets = try container.decode([String].self, forKey: .bullets)
        self.riskNote = try container.decodeIfPresent(String.self, forKey: .riskNote)
        self.toneTag = try container.decodeIfPresent(String.self, forKey: .toneTag)
        
        self.createdAt = try container.decodeIfPresent(Date.self, forKey: .createdAt) ?? Date()
        self.isOffline = try container.decodeIfPresent(Bool.self, forKey: .isOffline) ?? false
    }
    
    // Memberwise init
    init(title: String, summary: String, bullets: [String], riskNote: String?, toneTag: String?, createdAt: Date = Date(), isOffline: Bool = false) {
        self.title = title
        self.summary = summary
        self.bullets = bullets
        self.riskNote = riskNote
        self.toneTag = toneTag
        self.createdAt = createdAt
        self.isOffline = isOffline
    }
}


// MARK: - Phase 1: Decision Trace (Observability)
struct DecisionTrace: Codable, Identifiable {
    var id: UUID = UUID()
    let timestamp: Date
    let symbol: String
    
    // 1. Inputs
    let marketData: TraceMarketData
    let signals: [TraceSignal]
    let scores: TraceScores
    
    // 2. Logic Gates
    let gatingResults: [GatingResult]
    let churnGuard: ChurnGuardResult? // Phase 2
    
    // 3. Final Output
    let finalDecision: SignalAction
    let decisionScore: Double
    let reason: String
    
    // 4. Execution Context
    let executionPlan: TraceExecutionPlan?
    let contributors: [String] // Module names active
}

struct TraceMarketData: Codable {
    let price: Double
    let dataTimestamp: Date
    let freshnessSeconds: Double
    let source: String
}

struct TraceSignal: Codable {
    let source: String // e.g. "Orion"
    let direction: String // "BULL", "BEAR"
    let strength: Double // 0-100
    let confidence: Double // 0-100
    let timeframe: String // "1H", "1D"
}

struct TraceScores: Codable {
    let alphaScore: Double // Primary signal
    let riskScore: Double // Volatility inverted
    let stabilityScore: Double // Data quality
    let costScore: Double // Spread/Fees (Phase 3)
}

struct GatingResult: Codable {
    let ruleName: String
    let passed: Bool
    let reason: String
}

// MARK: - Phase 2: Churn Guard
struct ChurnGuardResult: Codable {
    let isBlocked: Bool
    let ruleTriggered: String? // "Cooldown", "Hysteresis", "Idempotency"
    let lockoutRemaining: TimeInterval // Seconds
    let originalDecision: SignalAction // What it wanted to do
}

struct TraceExecutionPlan: Codable {
    let targetSize: Double
    let riskRisk: Double
    let stopLoss: Double?
}

// MARK: - Legacy / Export Support
struct StandardModuleOutput: Codable, Sendable {
    let direction: String // "AL", "SAT", "TUT"
    let strength: Double // 0-100
    let confidence: Double // 0-100
    let timeframe: String // "1H", "1D"
    let reasons: [String]
}
// MARK: - AGORA V2: Protocol Models

/// The single source of truth for a decision's lifecycle.
struct AgoraTrace: Codable, Identifiable {
    let id: UUID
    let timestamp: Date
    let symbol: String
    
    // 1. Origin
    let candidateSource: CandidateSource
    let dataHealth: DataHealthSnapshot
    
    // 2. The Great Debate (Münazara)
    let debate: AgoraDebate
    
    // 3. Risk Gate
    let riskEvaluation: RiskGateResult
    
    // 4. Final Verdict
    let finalDecision: AgoraDecision
    
    // 5. Heimdall Debug Info
    let dataSourceUsage: [String: String] // e.g. "Price": "Yahoo (Cached)"
    let unusedFactors: [String] // e.g. "Phoenix (502)", "Macro (Missing)"
}

enum CandidateSource: String, Codable {
    case watchlist = "WATCHLIST" // Periodic scan
    case scout = "SCOUT"         // Opportunity scanner
    case hermes = "HERMES"       // News trigger
    case manual = "MANUAL"       // User requested
}

struct DataHealthSnapshot: Codable {
    let freshnessScore: Double // 0-100
    let missingModules: [String]
    let isAcceptable: Bool
    
    // Computed property for logic compatibility
    var healthScore: Double {
        // Penalty for missing modules?
        let penalty = Double(missingModules.count) * 10.0
        return max(0.0, freshnessScore - penalty)
    }
}

// --- The Debate ---

struct AgoraDebate: Codable {
    let claimant: ModuleOpinion? // Can be nil if no valid claim
    let opinions: [ModuleOpinion] // All opinions including claimant
    let consensusParams: ConsensusParams
}

enum AgoraStance: String, Codable {
    case claim = "CLAIM"       // I am leading this decision
    case support = "SUPPORT"   // I agree
    case object = "OBJECT"     // I disagree
    case abstain = "ABSTAIN"   // No data / Neutral
}

struct ModuleOpinion: Codable, Identifiable, Sendable {
    var id: String { module.rawValue }
    let module: EngineTag
    var stance: AgoraStance
    let preferredAction: SignalAction
    
    // Computed property for backward compatibility in code
    var claim: SignalAction { preferredAction }

    let strength: Double // Normalized 0-1 (Conviction)
    let score: Double // Raw Score 0-100 (For Consensus 2.0)
    let confidence: Double
    let evidence: [String]
    
    // Custom Keys to handle migration
    enum CodingKeys: String, CodingKey {
        case module, stance, preferredAction, claim, strength, score, confidence, evidence
    }
    
    // Helper init
    init(module: EngineTag, stance: AgoraStance = .abstain, preferredAction: SignalAction, strength: Double, score: Double, confidence: Double, evidence: [String]) {
        self.module = module
        self.stance = stance
        self.preferredAction = preferredAction
        self.strength = strength
        self.score = score
        self.confidence = confidence
        self.evidence = evidence
    }
    
    // Robust Decoder (Anti-Crash)
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        self.module = try container.decode(EngineTag.self, forKey: .module)
        self.stance = try container.decodeIfPresent(AgoraStance.self, forKey: .stance) ?? .abstain
        self.strength = try container.decode(Double.self, forKey: .strength)
        self.confidence = try container.decode(Double.self, forKey: .confidence)
        self.evidence = try container.decode([String].self, forKey: .evidence)
        
        // MIGRATION LOGIC:
        
        // 1. Preferred Action
        if let action = try container.decodeIfPresent(SignalAction.self, forKey: .preferredAction) {
            self.preferredAction = action
        } else if let legacyClaim = try container.decodeIfPresent(SignalAction.self, forKey: .claim) {
            self.preferredAction = legacyClaim
        } else {
            self.preferredAction = .hold
        }
        
        // 2. Score (New Field) - Reconstruct if missing
        if let s = try container.decodeIfPresent(Double.self, forKey: .score) {
            self.score = s
        } else {
            // Reconstruct approximate score from Action + Strength
            // Buy: 50 + (Strength * 50)
            // Sell: 50 - (Strength * 50)
            // Hold: 50
            if self.preferredAction == .buy {
                self.score = 50.0 + (self.strength * 50.0)
            } else if self.preferredAction == .sell {
                self.score = 50.0 - (self.strength * 50.0)
            } else {
                self.score = 50.0
            }
        }
    }
    
    // Encoder (Forward only)
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(module, forKey: .module)
        try container.encode(stance, forKey: .stance)
        try container.encode(preferredAction, forKey: .preferredAction)
        try container.encode(strength, forKey: .strength)
        try container.encode(score, forKey: .score)
        try container.encode(confidence, forKey: .confidence)
        try container.encode(evidence, forKey: .evidence)
    }
}

struct ConsensusParams: Codable {
    let totalClaimStrength: Double
    let totalObjectionStrength: Double
    let netScore: Double // (Claim - Objection)
    let deliberationText: String // Turkish Summary ("Orion'un al sinyali Atlas tarafından reddedildi...")
}

// --- Risk ---

struct RiskGateResult: Codable {
    let isApproved: Bool
    let riskBudgetR: Double // e.g. 2.5 (2.5% of Equity)
    let deltaR: Double // This trade adds +0.5R
    let maxR: Double // Limit 3.0R
    let reason: String // "Bütçe dolu (2.9R / 3.0R)"
}

// --- Verdict ---

// --- Verdict ---

struct AgoraDecision: Codable {
    let action: SignalAction
    let quantity: Double // Suggestion (Phase 1)
    let executionPlan: ExecutionPlan? // NEW: Full Plan
    let rationale: String 
    let executionStrategy: String 
}

struct ExecutionPlan: Codable {
    let targetAction: SignalAction
    let targetSizeR: Double // e.g. 0.5R
    let entryGuidance: PhoenixGuidance?
    let riskPlan: RiskPlan
    let validityWindow: TimeInterval // TTL
}

struct PhoenixGuidance: Codable {
    let priceBand: String // "Lower Channel", "Mid Channel"
    let recommendedEntry: String // "Wait for pullback to X" or "Enter Now"
    let confidence: Double
}

struct RiskPlan: Codable {
    let stopLoss: Double?
    let takeProfit: Double?
    let maxDrawdown: Double? // For trailing
}

// Helpers
extension SignalAction {
    var isBullish: Bool { return self == .buy }
    var isBearish: Bool { return self == .sell }
}
